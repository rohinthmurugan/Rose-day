<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy Rose Day Nilave</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body,
        html {
            margin: 0;
            height: 100%;
            background-color: #020002;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            overflow: hidden;
            font-family: 'Georgia', serif;
        }

        .header {
            margin-top: 8vh;
            z-index: 10;
            text-align: center;
            pointer-events: none;
        }

        h1 {
            color: #ff3366;
            font-family: 'Great Vibes', cursive;
            font-size: clamp(3rem, 5vw, 5rem);
            text-shadow: 0 0 30px rgba(255, 51, 102, 0.6);
            margin: 0;
            line-height: 1.2;
        }

        p {
            color: #ff99ac;
            font-style: italic;
            font-size: 1.1rem;
            opacity: 0.8;
            margin-top: 10px;
            letter-spacing: 1px;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }

        .footer {
            margin-bottom: 12vh;
            z-index: 10;
        }

        .bloom-btn {
            background: rgba(30, 0, 10, 0.4);
            border: 1px solid #ff3366;
            color: #ff3366;
            padding: 16px 45px;
            border-radius: 50px;
            letter-spacing: 3px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.4s ease;
            backdrop-filter: blur(5px);
            font-size: 0.9rem;
        }

        .bloom-btn:hover {
            background: #ff3366;
            color: white;
            box-shadow: 0 0 35px rgba(255, 51, 102, 0.6);
            transform: scale(1.05);
        }
    </style>
</head>

<body>

    <div class="header">
        <h1>Happy Rose Day Nilave</h1>
        <p>A rose that lasts forever, just like my love.</p>
    </div>

    <div id="canvas-container"></div>

    <div class="footer">
        <button class="bloom-btn" onclick="bloom()">BLOOM & GLOW</button>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- SCENE ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020002, 0.05);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        // Positioned further back (Z=22) to shrink the rose comfortably between text/button.
        camera.position.set(0, 6, 22);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        container.appendChild(renderer.domElement);


        // --- MATERIALS (UPDATED) ---
        // Brighter Pink/Magenta Petals
        const petalMaterial = new THREE.MeshPhysicalMaterial({
            color: 0xff3366,        // Vibrant Magenta/Pink
            emissive: 0x550022,     // Strong inner glow to look "light"
            roughness: 0.5,
            metalness: 0.0,
            reflectivity: 0.3,
            sheen: 1.5,
            sheenColor: 0xffb3c6,   // Pale pink sheen
            sheenRoughness: 0.4,
            clearcoat: 0.1,
            side: THREE.DoubleSide
        });

        // Pale Green Natural Stem
        const stemMaterial = new THREE.MeshStandardMaterial({
            color: 0x90EE90,        // Pale Light Green
            roughness: 0.6,
            bumpScale: 0.1
        });


        // --- LIGHTING ---
        const ambient = new THREE.AmbientLight(0x221122, 0.8); // Slightly brighter ambient
        scene.add(ambient);

        const spot = new THREE.SpotLight(0xff99aa, 60); // Bright key light
        spot.position.set(2, 10, 8);
        spot.angle = 0.4;
        spot.penumbra = 1;
        spot.castShadow = true;
        scene.add(spot);

        const rim = new THREE.SpotLight(0xffcce6, 40);
        rim.position.set(-5, 5, -8);
        rim.lookAt(0, 2, 0);
        scene.add(rim);

        const fill = new THREE.PointLight(0x331144, 5);
        fill.position.set(5, 0, 0);
        scene.add(fill);


        // --- GEOMETRY ---
        const masterGroup = new THREE.Group();
        // Shifted UP to y=1.5 to center perfectly in the layout gap
        masterGroup.position.set(0, 1.5, 0);
        masterGroup.rotation.x = 0.4;

        scene.add(masterGroup);
        const roseGroup = new THREE.Group();
        masterGroup.add(roseGroup);

        function createBroadPetal() {
            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.bezierCurveTo(1.1, 0.3, 1.5, 1.0, 1.2, 1.8);
            shape.bezierCurveTo(0.8, 2.2, -0.8, 2.2, -1.2, 1.8);
            shape.bezierCurveTo(-1.5, 1.0, -1.1, 0.3, 0, 0);
            const geometry = new THREE.ShapeGeometry(shape, 30);
            const pos = geometry.attributes.position;
            const v = new THREE.Vector3();
            for (let i = 0; i < pos.count; i++) {
                v.fromBufferAttribute(pos, i);
                v.z += Math.pow(v.x, 2) * 0.4;
                v.z += Math.pow(v.y / 2.2, 2) * 1.0;
                pos.setXYZ(i, v.x, v.y, v.z);
            }
            geometry.computeVertexNormals();
            geometry.translate(0, -0.2, 0);
            return geometry;
        }

        const petalGeo = createBroadPetal();
        const petals = [];

        const layers = [
            { count: 3, radius: 0.02, y: 0.0, scale: 0.2, rotX: 1.7, bloomRot: 1.4 },
            { count: 4, radius: 0.08, y: 0.04, scale: 0.3, rotX: 1.65, bloomRot: 1.3 },
            { count: 5, radius: 0.18, y: 0.08, scale: 0.45, rotX: 1.6, bloomRot: 1.1 },
            { count: 6, radius: 0.32, y: 0.14, scale: 0.6, rotX: 1.5, bloomRot: 0.9 },
            { count: 7, radius: 0.55, y: 0.20, scale: 0.8, rotX: 1.4, bloomRot: 0.7 },
            { count: 7, radius: 0.80, y: 0.28, scale: 0.95, rotX: 1.3, bloomRot: 0.5 },
            { count: 8, radius: 1.10, y: 0.36, scale: 1.15, rotX: 1.25, bloomRot: 0.3 },
            { count: 9, radius: 1.40, y: 0.42, scale: 1.3, rotX: 1.2, bloomRot: 0.2 }
        ];

        let totalPetals = 0;
        layers.forEach((l, lIdx) => {
            const step = (Math.PI * 2) / l.count;
            const startAngle = lIdx * 0.5;
            for (let i = 0; i < l.count; i++) {
                const angle = i * step + startAngle;
                const pivot = new THREE.Object3D();
                pivot.rotation.y = angle;
                pivot.position.y = l.y;
                const mesh = new THREE.Mesh(petalGeo, petalMaterial);
                mesh.position.set(0, 0, l.radius);
                mesh.scale.set(l.scale, l.scale, l.scale);
                mesh.rotation.x = l.rotX;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { startRot: l.rotX, endRot: l.bloomRot, layerIdx: lIdx };
                pivot.add(mesh);
                roseGroup.add(pivot);
                petals.push(mesh);
            }
        });

        // CURVY STEM
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, -7, 0),         // Bottom anchored center
            new THREE.Vector3(1.0, -4.5, 0.5),   // Swoop Right
            new THREE.Vector3(-0.8, -2.0, -0.5), // Swoop Left
            new THREE.Vector3(0, 0, 0)           // Meet flower
        ]);
        const stemGeo = new THREE.TubeGeometry(curve, 40, 0.12, 12, false);
        const stem = new THREE.Mesh(stemGeo, stemMaterial);
        stem.castShadow = true;
        masterGroup.add(stem);

        // LEAVES
        const leafShape = new THREE.Shape();
        leafShape.moveTo(0, 0);
        leafShape.bezierCurveTo(0.3, 0.3, 0.5, 1.0, 0, 2.2);
        leafShape.bezierCurveTo(-0.5, 1.0, -0.3, 0.3, 0, 0);
        const leafGeo = new THREE.ExtrudeGeometry(leafShape, { depth: 0.02, bevelEnabled: true, bevelThickness: 0.01 });
        const pos = leafGeo.attributes.position;
        const v = new THREE.Vector3();
        for (let i = 0; i < pos.count; i++) {
            v.fromBufferAttribute(pos, i);
            v.z -= Math.pow(v.y, 2) * 0.15; // Deeper leaf curl
            pos.setXYZ(i, v.x, v.y, v.z);
        }
        leafGeo.computeVertexNormals();

        function attachLeaf(y, ry, rz, s) {
            const p = new THREE.Object3D();
            // Approximate position on the curve? 
            // For simplicity in this static setup, we just place them relative to origin but shift 
            // the whole thing. The stem is curved, so straight Y offset might look detached.
            // Better to manually place near where the curve is.
            // Curve goes roughly through (0,-2,0)
            p.position.set(0, y, 0);
            p.rotation.y = ry;
            const m = new THREE.Mesh(leafGeo, stemMaterial);
            m.scale.set(s, s, s);
            m.rotation.x = -1.0;
            m.rotation.z = rz;
            m.position.x = 0.15;
            p.add(m);
            masterGroup.add(p);
        }
        // Manually tweaked positions to sit on the curvy stem
        attachLeaf(-1.8, 0.5, 0.2, 0.8);
        attachLeaf(-3.5, 3.8, -0.3, 0.9);

        // PARTICLES
        const pGeo = new THREE.BufferGeometry();
        const pCount = 300;
        const pPos = new Float32Array(pCount * 3);
        for (let i = 0; i < pCount * 3; i++) pPos[i] = (Math.random() - 0.5) * 20;
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        const pMat = new THREE.PointsMaterial({ color: 0xffaacc, size: 0.05, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending });
        const parts = new THREE.Points(pGeo, pMat);
        scene.add(parts);

        // --- ANIMATION ---
        let blooming = false;
        let bloomTime = 0;
        window.bloom = () => { blooming = true; };

        const mouse = new THREE.Vector2();
        window.addEventListener('mousemove', e => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            masterGroup.rotation.y = THREE.MathUtils.lerp(masterGroup.rotation.y, mouse.x * 0.2, 0.05);
            masterGroup.rotation.x = THREE.MathUtils.lerp(masterGroup.rotation.x, 0.4 - mouse.y * 0.1, 0.05);

            stem.rotation.z = Math.sin(t * 0.5) * 0.02;

            if (blooming && bloomTime < 1) bloomTime += 0.005;

            petals.forEach(p => {
                const layerDelay = (7 - p.userData.layerIdx) * 0.1;
                const prog = Math.max(0, Math.min(1, (bloomTime * 2.2) - layerDelay));
                const ease = 1 - Math.pow(1 - prog, 3);

                if (blooming) {
                    p.rotation.x = THREE.MathUtils.lerp(p.userData.startRot, p.userData.endRot, ease);
                }
            });

            parts.position.y += 0.005;
            if (parts.position.y > 10) parts.position.y = -10;

            camera.lookAt(0, 1.5, 0); // Focus on flower head

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>